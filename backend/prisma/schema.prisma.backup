generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                String    @id @default(cuid())
  walletAddress     String    @unique
  ens               String?
  email             String?   @unique
  emailVerified     Boolean   @default(false)
  
  // Profile
  username          String?   @unique
  bio               String?
  avatar            String?
  location          String?
  timezone          String?
  
  // Reputation
  builderScore      Int       @default(0)
  humanPassportScore Float?
  worldIdVerified   Boolean   @default(false)
  
  // Talent Protocol Integration
  talentProtocolId        String?
  talentProtocolUsername  String?
  talentProtocolVerified  Boolean   @default(false)
  talentTokenBalance      String?
  talentSupporterCount    Int       @default(0)
  talentTotalRaised       String?
  talentProtocolScore     Int       @default(0)
  talentProtocolSyncedAt  DateTime?
  talentProtocolData      Json?     // Full profile data cache
  
  // Compliance
  kycStatus         KycStatus @default(NOT_STARTED)
  kycProvider       String?
  kycData           Json?
  taxCountry        String?
  ofacScreened      Boolean   @default(false)
  ofacScreenedAt    DateTime?
  
  // Timestamps
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  lastLoginAt       DateTime?
  
  // Gamification
  gamificationScore Int       @default(0)
  
  // Relations
  teams             TeamMember[]
  projects          Project[]
  hackathonRegs     HackathonRegistration[]
  grants            GrantApplication[]
  votes             Vote[]
  comments          Comment[]
  roomParticipants  RoomParticipant[]
  roomMessages      RoomMessage[]
  userBadges        UserBadge[]
  userChallenges    UserChallenge[]
  leaderboardEntries LeaderboardEntry[]
  teamMatchingProfile TeamMatchingProfile?
  sentMatches       TeamMatch[] @relation("MatchSender")
  receivedMatches   TeamMatch[] @relation("MatchReceiver")
  
  @@index([walletAddress])
  @@index([email])
  @@index([builderScore])
  @@index([gamificationScore])
}

enum KycStatus {
  NOT_STARTED
  PENDING
  APPROVED
  REJECTED
}

model Hackathon {
  id                String    @id @default(cuid())
  slug              String    @unique
  
  // Basic info
  name              String
  tagline           String?
  description       String
  bannerImage       String?
  logoImage         String?
  
  // Organizer
  organizerId       String
  organizerName     String
  organizerEmail    String
  organizerWallet   String
  
  // Dates
  registrationStart DateTime
  registrationEnd   DateTime
  eventStart        DateTime
  eventEnd          DateTime
  submissionDeadline DateTime
  judgingStart      DateTime
  judgingEnd        DateTime
  winnersAnnounced  DateTime?
  
  // Location
  locationType      LocationType
  location          String?
  isOnline          Boolean   @default(false)
  
  // Blockchain
  chains            String[]  // ["arbitrum", "base", "optimism"]
  
  // Prizes
  totalPrizePool    Decimal   @db.Decimal(18, 2)
  currency          String    @default("USDC")
  prizeDistribution Json
  
  // Settings
  maxParticipants   Int?
  requiresApproval  Boolean   @default(false)
  minTeamSize       Int       @default(1)
  maxTeamSize       Int       @default(5)
  
  // Tracks/Categories
  tracks            Track[]
  
  // Status
  status            HackathonStatus @default(DRAFT)
  
  // Metadata
  tags              String[]
  sponsors          Json[]
  judges            Json[]
  schedule          Json?
  resources         Json?
  
  // Timestamps
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  // Relations
  registrations     HackathonRegistration[]
  projects          Project[]
  networkingRooms   NetworkingRoom[]
  badges            Badge[]
  challenges        Challenge[]
  leaderboardEntries LeaderboardEntry[]
  userBadges        UserBadge[]
  userChallenges    UserChallenge[]
  teamMatchingProfiles TeamMatchingProfile[]
  teamMatches       TeamMatch[]
  
  @@index([status])
  @@index([eventStart])
}

enum LocationType {
  IN_PERSON
  HYBRID
  ONLINE
}

enum HackathonStatus {
  DRAFT
  PUBLISHED
  REGISTRATION_OPEN
  REGISTRATION_CLOSED
  ONGOING
  JUDGING
  COMPLETED
  CANCELLED
}

model Track {
  id            String     @id @default(cuid())
  hackathonId   String
  name          String
  description   String?
  prizeAmount   Decimal    @db.Decimal(18, 2)
  
  hackathon     Hackathon  @relation(fields: [hackathonId], references: [id], onDelete: Cascade)
  projects      Project[]
  networkingRooms NetworkingRoom[] @relation("NetworkingRoomTrack")
  
  @@index([hackathonId])
}

model HackathonRegistration {
  id              String     @id @default(cuid())
  userId          String
  hackathonId     String
  
  status          RegistrationStatus @default(PENDING)
  approvedAt      DateTime?
  
  // Team
  teamId          String?
  teamRole        String?    // "leader", "member"
  
  // Metadata
  applicationData Json?
  
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt
  
  user            User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  hackathon       Hackathon  @relation(fields: [hackathonId], references: [id], onDelete: Cascade)
  team            Team?      @relation(fields: [teamId], references: [id])
  
  @@unique([userId, hackathonId])
  @@index([hackathonId])
  @@index([teamId])
}

enum RegistrationStatus {
  PENDING
  APPROVED
  REJECTED
  WAITLISTED
}

model Team {
  id              String     @id @default(cuid())
  name            String
  hackathonId     String
  
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt
  
  members         TeamMember[]
  projects        Project[]
  registrations   HackathonRegistration[]
  
  @@index([hackathonId])
}

model TeamMember {
  id        String   @id @default(cuid())
  teamId    String
  userId    String
  role      String   @default("member") // "leader", "member"
  
  createdAt DateTime @default(now())
  
  team      Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([teamId, userId])
  @@index([userId])
}

model Project {
  id              String     @id @default(cuid())
  slug            String     @unique
  
  // Basic info
  name            String
  tagline         String?
  description     String
  coverImage      String?
  
  // Hackathon
  hackathonId     String
  trackId         String?
  
  // Team
  teamId          String?
  creatorId       String
  
  // Submission
  demoUrl         String?
  videoUrl        String?
  githubUrl       String?
  figmaUrl        String?
  
  // Blockchain
  contracts       Json?      // { arbitrum: "0x...", base: "0x..." }
  techStack       String[]
  
  // Judging
  judgeScores     Json?
  finalScore      Float?
  rank            Int?
  prizeWon        Decimal?   @db.Decimal(18, 2)
  
  // AI checks
  plagiarismScore Float?
  plagiarismReport Json?
  
  // Status
  status          ProjectStatus @default(DRAFT)
  submittedAt     DateTime?
  
  // Post-hackathon
  continued       Boolean   @default(false)
  fundingRaised   Decimal?  @db.Decimal(18, 2)
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  hackathon       Hackathon @relation(fields: [hackathonId], references: [id], onDelete: Cascade)
  track           Track?    @relation(fields: [trackId], references: [id])
  team            Team?     @relation(fields: [teamId], references: [id])
  creator         User      @relation(fields: [creatorId], references: [id])
  votes           Vote[]
  comments        Comment[]
  grants          GrantApplication[]
  
  @@index([hackathonId])
  @@index([trackId])
  @@index([teamId])
  @@index([status])
}

enum ProjectStatus {
  DRAFT
  SUBMITTED
  UNDER_REVIEW
  APPROVED
  REJECTED
  WINNER
}

model Vote {
  id          String   @id @default(cuid())
  userId      String
  projectId   String
  
  weight      Int      @default(1) // Quadratic voting
  
  createdAt   DateTime @default(now())
  
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  
  @@unique([userId, projectId])
  @@index([projectId])
}

model Comment {
  id          String   @id @default(cuid())
  userId      String
  projectId   String
  
  content     String
  
  // Feedback fields
  rating      Int?     // 1-5 star rating (for mentors/judges)
  feedbackType FeedbackType @default(COMMENT)
  userRole    UserRole @default(PARTICIPANT) // Role of the user giving feedback
  isPublic    Boolean  @default(true) // Public comments visible to all
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  
  @@index([projectId])
  @@index([userId])
  @@index([feedbackType])
  @@index([userRole])
  @@index([createdAt])
}

enum FeedbackType {
  COMMENT
  SUGGESTION
  PRAISE
  WARNING
  QUESTION
}

enum UserRole {
  PARTICIPANT
  MENTOR
  JUDGE
  ORGANIZER
}

model GrantApplication {
  id              String     @id @default(cuid())
  userId          String
  projectId       String
  
  // Grant details
  grantProgram    String     // "Arbitrum Foundation", "Optimism RetroPGF", etc.
  amountRequested Decimal    @db.Decimal(18, 2)
  
  // Application
  proposal        String
  milestones      Json
  budget          Json
  
  // Status
  status          GrantStatus @default(DRAFT)
  submittedAt     DateTime?
  decidedAt       DateTime?
  
  // Result
  amountApproved  Decimal?   @db.Decimal(18, 2)
  
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt
  
  user            User       @relation(fields: [userId], references: [id])
  project         Project    @relation(fields: [projectId], references: [id], onDelete: Cascade)
  
  @@index([projectId])
  @@index([status])
}

enum GrantStatus {
  DRAFT
  SUBMITTED
  UNDER_REVIEW
  APPROVED
  REJECTED
}

model NetworkingRoom {
  id              String    @id @default(cuid())
  hackathonId     String
  trackId         String?
  
  // Room info
  name            String
  description     String?
  track           String?   // "DeFi", "NFT", "AI", "General", etc.
  roomType        RoomType  @default(GENERAL)
  
  // Settings
  maxParticipants Int?      @default(50)
  isPrivate       Boolean   @default(false)
  password        String?
  
  // Video/Audio
  videoEnabled    Boolean   @default(true)
  audioEnabled    Boolean   @default(true)
  
  // Status
  isActive        Boolean   @default(true)
  
  // Metadata
  metadata        Json?     // Additional settings, breakout sessions, etc.
  
  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  // Relations
  hackathon       Hackathon @relation(fields: [hackathonId], references: [id], onDelete: Cascade)
  trackRelation   Track?    @relation("NetworkingRoomTrack", fields: [trackId], references: [id], onDelete: SetNull)
  participants    RoomParticipant[]
  messages        RoomMessage[]
  breakoutSessions BreakoutSession[] @relation("BreakoutSessionRoom")
  parentBreakoutSessions BreakoutSession[] @relation("BreakoutSessionParent")
  
  @@index([hackathonId])
  @@index([trackId])
  @@index([isActive])
}

enum RoomType {
  GENERAL
  TRACK_BASED
  MENTOR_OFFICE_HOURS
  JUDGE_QA
  BREAKOUT
}

model RoomParticipant {
  id              String    @id @default(cuid())
  roomId          String
  userId          String
  
  // Status
  isActive        Boolean   @default(true)
  joinedAt        DateTime  @default(now())
  leftAt          DateTime?
  
  // Video/Audio state
  videoEnabled    Boolean   @default(true)
  audioEnabled    Boolean   @default(true)
  
  // WebRTC
  peerId          String?   // WebRTC peer ID
  streamId        String?   // Media stream ID
  
  // Metadata
  metadata        Json?     // Position in grid, breakout session, etc.
  
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  room            NetworkingRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)
  
  @@unique([roomId, userId])
  @@index([roomId])
  @@index([userId])
  @@index([isActive])
}

model RoomMessage {
  id              String    @id @default(cuid())
  roomId          String
  userId          String
  
  // Message content
  content         String
  messageType     MessageType @default(TEXT)
  
  // Attachments
  attachments     Json?     // Files, links, etc.
  
  // Status
  isEdited        Boolean   @default(false)
  isDeleted       Boolean   @default(false)
  editedAt        DateTime?
  
  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  room            NetworkingRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)
  
  @@index([roomId])
  @@index([userId])
  @@index([createdAt])
}

enum MessageType {
  TEXT
  SYSTEM
  FILE
  LINK
  EMOJI
}

model BreakoutSession {
  id              String    @id @default(cuid())
  roomId          String
  parentRoomId    String?   // If this is a sub-session
  
  // Session info
  name            String
  description     String?
  
  // Participants
  maxParticipants Int?      @default(10)
  
  // Status
  isActive        Boolean   @default(true)
  startedAt       DateTime  @default(now())
  endedAt         DateTime?
  
  // Metadata
  metadata        Json?
  
  room            NetworkingRoom @relation("BreakoutSessionRoom", fields: [roomId], references: [id], onDelete: Cascade)
  parentRoom      NetworkingRoom? @relation("BreakoutSessionParent", fields: [parentRoomId], references: [id], onDelete: SetNull)
  
  @@index([roomId])
  @@index([parentRoomId])
  @@index([isActive])
}

// Gamification Models

model Badge {
  id          String   @id @default(cuid())
  hackathonId String?
  
  // Badge info
  name        String
  description String
  icon        String?  // Emoji or icon URL
  rarity      BadgeRarity @default(COMMON)
  
  // Requirements
  badgeType   BadgeType
  requirement Json?    // Specific requirements (e.g., { "projects": 1, "feedback": 10 })
  points      Int      @default(0) // Points awarded when earned
  
  // NFT Reward
  nftReward   Boolean  @default(false)
  nftMetadata Json?    // NFT metadata if nftReward is true
  
  // Status
  isActive    Boolean  @default(true)
  
  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  hackathon   Hackathon? @relation(fields: [hackathonId], references: [id], onDelete: Cascade)
  userBadges  UserBadge[]
  
  @@index([hackathonId])
  @@index([badgeType])
  @@index([rarity])
  @@index([isActive])
}

enum BadgeRarity {
  COMMON
  RARE
  EPIC
  LEGENDARY
}

enum BadgeType {
  PROJECT_SUBMISSION
  FEEDBACK_GIVEN
  FEEDBACK_RECEIVED
  NETWORKING
  TEAM_COLLABORATION
  DAILY_CHALLENGE
  WINNER
  PARTICIPATION
  MENTOR_ACTIVITY
  JUDGE_ACTIVITY
  CUSTOM
}

model UserBadge {
  id          String   @id @default(cuid())
  userId      String
  badgeId     String
  hackathonId String?
  
  // Metadata
  earnedAt    DateTime @default(now())
  nftTokenId  String?  // NFT token ID if minted
  nftTxHash   String?  // Transaction hash for NFT mint
  
  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  badge       Badge    @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  hackathon   Hackathon? @relation(fields: [hackathonId], references: [id], onDelete: Cascade)
  
  @@unique([userId, badgeId, hackathonId])
  @@index([userId])
  @@index([badgeId])
  @@index([hackathonId])
  @@index([earnedAt])
}

model Challenge {
  id          String   @id @default(cuid())
  hackathonId String?
  
  // Challenge info
  title       String
  description String
  challengeType ChallengeType
  
  // Requirements
  requirement Json     // Specific requirements
  points      Int      @default(50)
  
  // Timing
  startDate   DateTime
  endDate     DateTime
  isDaily     Boolean  @default(true)
  isActive    Boolean  @default(true)
  
  // NFT Reward
  nftReward   Boolean  @default(false)
  nftMetadata Json?
  
  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  hackathon   Hackathon? @relation(fields: [hackathonId], references: [id], onDelete: Cascade)
  userChallenges UserChallenge[]
  
  @@index([hackathonId])
  @@index([challengeType])
  @@index([startDate])
  @@index([endDate])
  @@index([isActive])
}

enum ChallengeType {
  PROJECT_UPDATE
  FEEDBACK_GIVEN
  NETWORKING_JOIN
  CODE_COMMIT
  DEMO_SHARE
  SOCIAL_SHARE
  CUSTOM
}

model UserChallenge {
  id          String   @id @default(cuid())
  userId      String
  challengeId String
  hackathonId String?
  
  // Completion
  completedAt DateTime @default(now())
  pointsEarned Int
  nftTokenId   String?  // NFT token ID if minted
  nftTxHash    String?  // Transaction hash for NFT mint
  
  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  challenge   Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  hackathon   Hackathon? @relation(fields: [hackathonId], references: [id], onDelete: Cascade)
  
  @@unique([userId, challengeId, hackathonId])
  @@index([userId])
  @@index([challengeId])
  @@index([hackathonId])
  @@index([completedAt])
}

model LeaderboardEntry {
  id          String   @id @default(cuid())
  userId      String
  hackathonId String
  
  // Scores
  totalScore  Int      @default(0)
  badgeCount  Int      @default(0)
  projectCount Int     @default(0)
  challengeCount Int   @default(0)
  
  // Ranking
  rank        Int?
  previousRank Int?
  
  // Timestamps
  lastUpdated DateTime @default(now())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  hackathon   Hackathon @relation(fields: [hackathonId], references: [id], onDelete: Cascade)
  
  @@unique([userId, hackathonId])
  @@index([userId])
  @@index([hackathonId])
  @@index([totalScore])
  @@index([rank])
}

// Team Matching Models

model TeamMatchingProfile {
  id              String    @id @default(cuid())
  userId          String    @unique
  hackathonId     String
  
  // Skills
  skills          String[]  // ["Solidity", "React", "Node.js", "DeFi", "NFT"]
  skillLevels     Json?     // { "Solidity": "expert", "React": "intermediate", ... }
  
  // GitHub Integration
  githubUsername  String?
  githubUrl       String?
  githubData      Json?     // { repos: [...], languages: {...}, activity: {...} }
  githubAnalyzedAt DateTime?
  
  // Preferences
  lookingFor      String[]  // ["frontend", "backend", "smart-contracts", "design"]
  preferredRole   String?   // "leader", "member", "flexible"
  teamSize        Json?     // { min: 2, max: 5, preferred: 4 }
  
  // Availability
  availability    String?   // "full-time", "part-time", "weekend"
  availableHours Json?     // { start: "09:00", end: "18:00", timezone: "UTC+3" }
  
  // Additional Info
  bio             String?
  experience      String?   // "beginner", "intermediate", "advanced", "expert"
  previousProjects Json?    // Array of previous project descriptions
  interests       String[]  // Additional interests/topics
  
  // Status
  isActive        Boolean   @default(true)
  isLookingForTeam Boolean @default(true)
  
  // AI Analysis
  aiAnalysis      Json?     // AI-generated analysis of skills and compatibility
  lastAnalyzedAt  DateTime?
  
  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  // Relations
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  hackathon      Hackathon @relation(fields: [hackathonId], references: [id], onDelete: Cascade)
  
  @@index([hackathonId])
  @@index([userId])
  @@index([isActive])
  @@index([isLookingForTeam])
  @@index([createdAt])
}

model TeamMatch {
  id              String    @id @default(cuid())
  senderId       String
  receiverId     String
  hackathonId    String
  
  // Match Details
  matchScore     Float     // 0.0 - 1.0 compatibility score
  skillScore     Float     // Skill complementarity score
  timezoneScore  Float     // Timezone compatibility score
  githubScore    Float?    // GitHub activity/quality score
  
  // AI Analysis
  aiReasoning    String?   // AI-generated explanation of the match
  strengths      String[]  // What makes this a good match
  considerations String[]  // Things to consider
  
  // Status
  status         MatchStatus @default(PENDING)
  
  // Actions
  senderAction   MatchAction? // "interested", "not_interested", null
  receiverAction MatchAction? // "interested", "not_interested", null
  
  // Metadata
  metadata       Json?     // Additional match data
  
  // Timestamps
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  respondedAt    DateTime?
  
  // Relations
  sender         User      @relation("MatchSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver       User      @relation("MatchReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  hackathon      Hackathon @relation(fields: [hackathonId], references: [id], onDelete: Cascade)
  
  @@unique([senderId, receiverId, hackathonId])
  @@index([senderId])
  @@index([receiverId])
  @@index([hackathonId])
  @@index([status])
  @@index([matchScore])
  @@index([createdAt])
}

enum MatchStatus {
  PENDING
  MUTUAL_INTEREST
  NOT_INTERESTED
  EXPIRED
}

enum MatchAction {
  INTERESTED
  NOT_INTERESTED
}

