generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id                String    @id @default(cuid())
  walletAddress     String    @unique
  ens               String?
  email             String?   @unique
  emailVerified     Boolean   @default(false)
  
  // Profile
  username          String?
  bio               String?
  avatar            String?
  location          String?
  timezone          String?
  
  // Reputation
  builderScore      Int       @default(0)
  humanPassportScore Float?
  worldIdVerified   Boolean   @default(false)
  
  // Talent Protocol Integration
  talentProtocolId        String?
  talentProtocolUsername  String?
  talentProtocolVerified  Boolean   @default(false)
  talentTokenBalance      String?
  talentSupporterCount    Int       @default(0)
  talentTotalRaised       String?
  talentProtocolScore     Int       @default(0)
  talentProtocolSyncedAt  DateTime?
  talentProtocolData      String?     // JSON stored as text in SQLite
  
  // Compliance
  kycStatus         String    @default("NOT_STARTED") // KycStatus enum as string
  kycProvider       String?
  kycData           String?     // JSON stored as text
  taxCountry        String?
  ofacScreened      Boolean   @default(false)
  ofacScreenedAt    DateTime?
  
  // Timestamps
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  lastLoginAt       DateTime?
  
  // Gamification
  gamificationScore Int       @default(0)
  
  // Relations
  teams             TeamMember[]
  projects          Project[]
  hackathonRegs     HackathonRegistration[]
  grants            GrantApplication[]
  votes             Vote[]
  comments          Comment[]
  roomParticipants  RoomParticipant[]
  roomMessages      RoomMessage[]
  userBadges        UserBadge[]
  userChallenges    UserChallenge[]
  leaderboardEntries LeaderboardEntry[]
  teamMatchingProfile TeamMatchingProfile?
  sentMatches       TeamMatch[] @relation("MatchSender")
  receivedMatches   TeamMatch[] @relation("MatchReceiver")
  
  @@index([walletAddress])
  @@index([email])
  @@index([builderScore])
  @@index([gamificationScore])
}

model Hackathon {
  id                String    @id @default(cuid())
  slug              String    @unique
  
  // Basic info
  name              String
  tagline           String?
  description       String
  bannerImage       String?
  logoImage         String?
  
  // Organizer
  organizerId       String
  organizerName     String
  organizerEmail    String
  organizerWallet   String
  
  // Dates
  registrationStart DateTime
  registrationEnd   DateTime
  eventStart        DateTime
  eventEnd          DateTime
  submissionDeadline DateTime
  judgingStart      DateTime
  judgingEnd        DateTime
  winnersAnnounced  DateTime?
  
  // Location
  locationType      String    // LocationType enum as string
  location          String?
  isOnline          Boolean   @default(false)
  
  // Blockchain - stored as comma-separated string in SQLite
  chains            String    // "arbitrum,base,optimism"
  
  // Prizes - stored as string in SQLite
  totalPrizePool    String    // Decimal stored as string
  currency          String    @default("USDC")
  prizeDistribution String    // JSON stored as text
  
  // Settings
  maxParticipants   Int?
  requiresApproval  Boolean   @default(false)
  minTeamSize       Int       @default(1)
  maxTeamSize       Int       @default(5)
  
  // Tracks/Categories
  tracks            Track[]
  
  // Status
  status            String    @default("DRAFT") // HackathonStatus enum as string
  
  // Metadata - stored as JSON strings
  tags              String    // Comma-separated tags
  sponsors          String?   // JSON stored as text
  judges            String?   // JSON stored as text
  schedule          String?   // JSON stored as text
  resources         String?   // JSON stored as text
  
  // Timestamps
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  // Relations
  registrations     HackathonRegistration[]
  projects          Project[]
  networkingRooms   NetworkingRoom[]
  badges            Badge[]
  challenges        Challenge[]
  leaderboardEntries LeaderboardEntry[]
  userBadges        UserBadge[]
  userChallenges    UserChallenge[]
  teamMatchingProfiles TeamMatchingProfile[]
  teamMatches       TeamMatch[]
  
  @@index([status])
  @@index([eventStart])
}

model Track {
  id            String     @id @default(cuid())
  hackathonId   String
  name          String
  description   String?
  prizeAmount   String     // Decimal stored as string
  
  hackathon     Hackathon  @relation(fields: [hackathonId], references: [id], onDelete: Cascade)
  projects      Project[]
  networkingRooms NetworkingRoom[] @relation("NetworkingRoomTrack")
  
  @@index([hackathonId])
}

model HackathonRegistration {
  id              String     @id @default(cuid())
  userId          String
  hackathonId     String
  
  status          String     @default("PENDING") // RegistrationStatus enum as string
  approvedAt      DateTime?
  
  // Team
  teamId          String?
  teamRole        String?    // "leader", "member"
  
  // Metadata
  applicationData String?    // JSON stored as text
  
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt
  
  user            User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  hackathon       Hackathon  @relation(fields: [hackathonId], references: [id], onDelete: Cascade)
  team            Team?      @relation(fields: [teamId], references: [id])
  
  @@unique([userId, hackathonId])
  @@index([hackathonId])
  @@index([teamId])
}

model Team {
  id              String     @id @default(cuid())
  name            String
  hackathonId     String
  
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt
  
  members         TeamMember[]
  projects        Project[]
  registrations   HackathonRegistration[]
  
  @@index([hackathonId])
}

model TeamMember {
  id        String   @id @default(cuid())
  teamId    String
  userId    String
  role      String   @default("member") // "leader", "member"
  
  createdAt DateTime @default(now())
  
  team      Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([teamId, userId])
  @@index([userId])
}

model Project {
  id              String     @id @default(cuid())
  slug            String     @unique
  
  // Basic info
  name            String
  tagline         String?
  description     String
  coverImage      String?
  
  // Hackathon
  hackathonId     String
  trackId         String?
  
  // Team
  teamId          String?
  creatorId       String
  
  // Submission
  demoUrl         String?
  videoUrl        String?
  githubUrl       String?
  figmaUrl        String?
  
  // Blockchain
  contracts       String?    // JSON stored as text
  techStack       String     // Comma-separated string
  
  // Judging
  judgeScores     String?    // JSON stored as text
  finalScore      Float?
  rank            Int?
  prizeWon        String?    // Decimal stored as string
  
  // AI checks
  plagiarismScore Float?
  plagiarismReport String?   // JSON stored as text
  
  // Status
  status          String     @default("DRAFT") // ProjectStatus enum as string
  submittedAt     DateTime?
  
  // Post-hackathon
  continued       Boolean   @default(false)
  fundingRaised   String?   // Decimal stored as string
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  hackathon       Hackathon @relation(fields: [hackathonId], references: [id], onDelete: Cascade)
  track           Track?    @relation(fields: [trackId], references: [id])
  team            Team?     @relation(fields: [teamId], references: [id])
  creator         User      @relation(fields: [creatorId], references: [id])
  votes           Vote[]
  comments        Comment[]
  grants          GrantApplication[]
  
  @@index([hackathonId])
  @@index([trackId])
  @@index([teamId])
  @@index([status])
}

model Vote {
  id          String   @id @default(cuid())
  userId      String
  projectId   String
  
  weight      Int      @default(1) // Quadratic voting
  
  createdAt   DateTime @default(now())
  
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  
  @@unique([userId, projectId])
  @@index([projectId])
}

model Comment {
  id          String   @id @default(cuid())
  userId      String
  projectId   String
  
  content     String
  
  // Feedback fields
  rating      Int?     // 1-5 star rating (for mentors/judges)
  feedbackType String  @default("COMMENT") // FeedbackType enum as string
  userRole    String   @default("PARTICIPANT") // UserRole enum as string
  isPublic    Boolean  @default(true) // Public comments visible to all
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  
  @@index([projectId])
  @@index([userId])
  @@index([feedbackType])
  @@index([userRole])
  @@index([createdAt])
}

model GrantApplication {
  id              String     @id @default(cuid())
  userId          String
  projectId       String
  
  // Grant details
  grantProgram    String     // "Arbitrum Foundation", "Optimism RetroPGF", etc.
  amountRequested String     // Decimal stored as string
  
  // Application
  proposal        String
  milestones      String     // JSON stored as text
  budget          String     // JSON stored as text
  
  // Status
  status          String     @default("DRAFT") // GrantStatus enum as string
  submittedAt     DateTime?
  decidedAt       DateTime?
  
  // Result
  amountApproved  String?    // Decimal stored as string
  
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt
  
  user            User       @relation(fields: [userId], references: [id])
  project         Project    @relation(fields: [projectId], references: [id], onDelete: Cascade)
  
  @@index([projectId])
  @@index([status])
}

model NetworkingRoom {
  id              String    @id @default(cuid())
  hackathonId     String
  trackId         String?
  
  // Room info
  name            String
  description     String?
  track           String?   // "DeFi", "NFT", "AI", "General", etc.
  roomType        String    @default("GENERAL") // RoomType enum as string
  
  // Settings
  maxParticipants Int?      @default(50)
  isPrivate       Boolean   @default(false)
  password        String?
  
  // Video/Audio
  videoEnabled    Boolean   @default(true)
  audioEnabled    Boolean   @default(true)
  
  // Status
  isActive        Boolean   @default(true)
  
  // Metadata
  metadata        String?   // JSON stored as text
  
  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  // Relations
  hackathon       Hackathon @relation(fields: [hackathonId], references: [id], onDelete: Cascade)
  trackRelation   Track?    @relation("NetworkingRoomTrack", fields: [trackId], references: [id], onDelete: SetNull)
  participants    RoomParticipant[]
  messages        RoomMessage[]
  breakoutSessions BreakoutSession[] @relation("BreakoutSessionRoom")
  parentBreakoutSessions BreakoutSession[] @relation("BreakoutSessionParent")
  
  @@index([hackathonId])
  @@index([trackId])
  @@index([isActive])
}

model RoomParticipant {
  id              String    @id @default(cuid())
  roomId          String
  userId          String
  
  // Status
  isActive        Boolean   @default(true)
  joinedAt        DateTime  @default(now())
  leftAt          DateTime?
  
  // Video/Audio state
  videoEnabled    Boolean   @default(true)
  audioEnabled    Boolean   @default(true)
  
  // WebRTC
  peerId          String?   // WebRTC peer ID
  streamId        String?   // Media stream ID
  
  // Metadata
  metadata        String?   // JSON stored as text
  
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  room            NetworkingRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)
  
  @@unique([roomId, userId])
  @@index([roomId])
  @@index([userId])
  @@index([isActive])
}

model RoomMessage {
  id              String    @id @default(cuid())
  roomId          String
  userId          String
  
  // Message content
  content         String
  messageType     String    @default("TEXT") // MessageType enum as string
  
  // Attachments
  attachments     String?   // JSON stored as text
  
  // Status
  isEdited        Boolean   @default(false)
  isDeleted       Boolean   @default(false)
  editedAt        DateTime?
  
  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  room            NetworkingRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)
  
  @@index([roomId])
  @@index([userId])
  @@index([createdAt])
}

model BreakoutSession {
  id              String    @id @default(cuid())
  roomId          String
  parentRoomId    String?   // If this is a sub-session
  
  // Session info
  name            String
  description     String?
  
  // Participants
  maxParticipants Int?      @default(10)
  
  // Status
  isActive        Boolean   @default(true)
  startedAt       DateTime  @default(now())
  endedAt         DateTime?
  
  // Metadata
  metadata        String?   // JSON stored as text
  
  room            NetworkingRoom @relation("BreakoutSessionRoom", fields: [roomId], references: [id], onDelete: Cascade)
  parentRoom      NetworkingRoom? @relation("BreakoutSessionParent", fields: [parentRoomId], references: [id], onDelete: SetNull)
  
  @@index([roomId])
  @@index([parentRoomId])
  @@index([isActive])
}

// Gamification Models

model Badge {
  id          String   @id @default(cuid())
  hackathonId String?
  
  // Badge info
  name        String
  description String
  icon        String?  // Emoji or icon URL
  rarity      String   @default("COMMON") // BadgeRarity enum as string
  
  // Requirements
  badgeType   String   // BadgeType enum as string
  requirement String?  // JSON stored as text
  points      Int      @default(0) // Points awarded when earned
  
  // NFT Reward
  nftReward   Boolean  @default(false)
  nftMetadata String?  // JSON stored as text
  
  // Status
  isActive    Boolean  @default(true)
  
  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  hackathon   Hackathon? @relation(fields: [hackathonId], references: [id], onDelete: Cascade)
  userBadges  UserBadge[]
  
  @@index([hackathonId])
  @@index([badgeType])
  @@index([rarity])
  @@index([isActive])
}

model UserBadge {
  id          String   @id @default(cuid())
  userId      String
  badgeId     String
  hackathonId String?
  
  // Metadata
  earnedAt    DateTime @default(now())
  nftTokenId  String?  // NFT token ID if minted
  nftTxHash   String?  // Transaction hash for NFT mint
  
  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  badge       Badge    @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  hackathon   Hackathon? @relation(fields: [hackathonId], references: [id], onDelete: Cascade)
  
  @@unique([userId, badgeId, hackathonId])
  @@index([userId])
  @@index([badgeId])
  @@index([hackathonId])
  @@index([earnedAt])
}

model Challenge {
  id          String   @id @default(cuid())
  hackathonId String?
  
  // Challenge info
  title       String
  description String
  challengeType String   // ChallengeType enum as string
  
  // Requirements
  requirement String   // JSON stored as text
  points      Int      @default(50)
  
  // Timing
  startDate   DateTime
  endDate     DateTime
  isDaily     Boolean  @default(true)
  isActive    Boolean  @default(true)
  
  // NFT Reward
  nftReward   Boolean  @default(false)
  nftMetadata String?  // JSON stored as text
  
  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  hackathon   Hackathon? @relation(fields: [hackathonId], references: [id], onDelete: Cascade)
  userChallenges UserChallenge[]
  
  @@index([hackathonId])
  @@index([challengeType])
  @@index([startDate])
  @@index([endDate])
  @@index([isActive])
}

model UserChallenge {
  id          String   @id @default(cuid())
  userId      String
  challengeId String
  hackathonId String?
  
  // Completion
  completedAt DateTime @default(now())
  pointsEarned Int
  nftTokenId   String?  // NFT token ID if minted
  nftTxHash    String?  // Transaction hash for NFT mint
  
  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  challenge   Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  hackathon   Hackathon? @relation(fields: [hackathonId], references: [id], onDelete: Cascade)
  
  @@unique([userId, challengeId, hackathonId])
  @@index([userId])
  @@index([challengeId])
  @@index([hackathonId])
  @@index([completedAt])
}

model LeaderboardEntry {
  id          String   @id @default(cuid())
  userId      String
  hackathonId String
  
  // Scores
  totalScore  Int      @default(0)
  badgeCount  Int      @default(0)
  projectCount Int     @default(0)
  challengeCount Int   @default(0)
  
  // Ranking
  rank        Int?
  previousRank Int?
  
  // Timestamps
  lastUpdated DateTime @default(now())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  hackathon   Hackathon @relation(fields: [hackathonId], references: [id], onDelete: Cascade)
  
  @@unique([userId, hackathonId])
  @@index([userId])
  @@index([hackathonId])
  @@index([totalScore])
  @@index([rank])
}

// Team Matching Models

model TeamMatchingProfile {
  id              String    @id @default(cuid())
  userId          String    @unique
  hackathonId     String
  
  // Skills
  skills          String    // Comma-separated string
  skillLevels     String?   // JSON stored as text
  
  // GitHub Integration
  githubUsername  String?
  githubUrl       String?
  githubData      String?   // JSON stored as text
  githubAnalyzedAt DateTime?
  
  // Preferences
  lookingFor      String    // Comma-separated string
  preferredRole   String?   // "leader", "member", "flexible"
  teamSize        String?   // JSON stored as text
  
  // Availability
  availability    String?   // "full-time", "part-time", "weekend"
  availableHours String?   // JSON stored as text
  
  // Additional Info
  bio             String?
  experience      String?   // "beginner", "intermediate", "advanced", "expert"
  previousProjects String?   // JSON stored as text
  interests       String    // Comma-separated string
  
  // Status
  isActive        Boolean   @default(true)
  isLookingForTeam Boolean @default(true)
  
  // AI Analysis
  aiAnalysis      String?   // JSON stored as text
  lastAnalyzedAt  DateTime?
  
  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  // Relations
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  hackathon      Hackathon @relation(fields: [hackathonId], references: [id], onDelete: Cascade)
  
  @@index([hackathonId])
  @@index([userId])
  @@index([isActive])
  @@index([isLookingForTeam])
  @@index([createdAt])
}

model TeamMatch {
  id              String    @id @default(cuid())
  senderId       String
  receiverId     String
  hackathonId    String
  
  // Match Details
  matchScore     Float     // 0.0 - 1.0 compatibility score
  skillScore     Float     // Skill complementarity score
  timezoneScore  Float     // Timezone compatibility score
  githubScore    Float?    // GitHub activity/quality score
  
  // AI Analysis
  aiReasoning    String?   // AI-generated explanation of the match
  strengths      String    // Comma-separated string
  considerations String    // Comma-separated string
  
  // Status
  status         String    @default("PENDING") // MatchStatus enum as string
  
  // Actions
  senderAction   String?   // MatchAction enum as string
  receiverAction String?   // MatchAction enum as string
  
  // Metadata
  metadata       String?   // JSON stored as text
  
  // Timestamps
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  respondedAt    DateTime?
  
  // Relations
  sender         User      @relation("MatchSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver       User      @relation("MatchReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  hackathon      Hackathon @relation(fields: [hackathonId], references: [id], onDelete: Cascade)
  
  @@unique([senderId, receiverId, hackathonId])
  @@index([senderId])
  @@index([receiverId])
  @@index([hackathonId])
  @@index([status])
  @@index([matchScore])
  @@index([createdAt])
}

